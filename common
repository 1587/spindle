#!/bin/sh
# Part of spindle http://asbradbury.org/projects/spindle
#
# See LICENSE file for copyright and license details

set -e

. ./config

run_qemu() {
  rm fifo.out fifo.in || true
  mkfifo fifo.out fifo.in
  qemu-system-arm -M versatilepb -cpu arm1136-r2 -m 256 -nographic -no-reboot \
        -kernel zImage -hda qemu_rootfs.sqf -drive file=$1,index=1,media=disk,cache=unsafe \
        -append "root=/dev/sda rw init=/sbin/init.sh panic=1 PATH=/bin:/sbin console=ttyAMA0 HOST=armv6l"\
        -net nic,model=rtl8139 -net user -redir tcp:22000::22 -daemonize -serial pipe:fifo \
        -pidfile qemu.pid
}

ssh_in_to_qemu() {
  ssh -i qemu_arm_key -p 22000 -lroot localhost "$@"
}

scp_in_to_qemu() {
  scp -i qemu_arm_key -P 22000 $1 root@localhost:$2
}

onvm_chroot() {
  ssh_in_to_qemu chroot /mnt "$@"
}

shutdown_qemu() {
  echo "sync" > fifo.in
  echo "umount /mnt" > fifo.in
  echo "exit" > fifo.in
  if [ -e qemu.pid ]; then
    QEMU_PID=$(cat qemu.pid)
    while [ -n "$QEMU_PID" ]; do 
      set +e
      kill -0 $QEMU_PID 2>/dev/null
      if [ $? -eq 0 ]; then
        printf "Qemu pid %s not finished yet. Waiting\n" "$QEMU_PID"
        sleep 1
      else
        QEMU_PID=""
      fi
      set -e
    done
  fi
  rm fifo.in
  rm fifo.out
#  sleep 15
}

attach_image_to_nbd() {
  # use -v as we seem to have problems otherwise...
  sudo qemu-nbd --nocache -v -c $2 $1 &
  sleep 5
}

detach_image_from_nbd() {
  sudo qemu-nbd -d $1
}

inspect_image() {
  cd work
  qemu-img create -f qed -b ../$1 temp.qed
  # Sigh http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=390433
  trap '[ -p fifo.in ] && shutdown_qemu' EXIT
  trap '[ -p fifo.in ] && shutdown_qemu; trap - INT; kill -INT $$' INT
  run_qemu temp.qed
  ssh_in_to_qemu # -t chroot /mnt bash -l
  shutdown_qemu
  cd $OLDPWD
}

branch_image() {
  qemu-img create -f qed -b $1 $2
}

write_image() {
  attach_image_to_nbd $1 /dev/nbd0 &&
  sudo dd if=/dev/nbd0 of=$2 bs=4M &&
  detach_image_from_nbd /dev/nbd0
}

convert_image() {
  qemu-img convert -f qed -O raw $1 $2
}

export_image_for_release() {
  cd work
  qemu-img create -f qed -b ../$1 temp.qed
  run_qemu temp.qed
  # Change mirror in sources.list to our preferred one. This will go horribly 
  # wrong if there is more than one entry in sources.list
  ssh_in_to_qemu sh -ex <<EOF
sed -i /mnt/etc/apt/sources.list -e "s|^deb [^ ]*|deb http://ftp.uk.debian.org/debian|"
EOF
  shutdown_qemu
  attach_image_to_nbd temp.qed /dev/nbd0
  sudo zerofree -v /dev/nbd0p2
  detach_image_from_nbd /dev/nbd0
  convert_image temp.qed ../$2
}

disable_starting_services() {
  ssh_in_to_qemu chroot /mnt sh -ex - <<EOF
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
printf '#!/bin/sh\nexit 101\n' > /usr/sbin/policy-rc.d
chmod 755 /usr/sbin/policy-rc.d
EOF
}

allow_starting_services() {
  ssh_in_to_qemu chroot /mnt sh -ex - <<EOF
rm /usr/sbin/policy-rc.d
EOF
}

save_space_using_hardlink() {
  onvm_chroot sh -l -e - <<\EOF
hardlink -t /usr/share/doc
EOF
}

download_if_necessary() {
  [ -f $(basename "$1") ] || wget "$1"
}

finish_image() {
  chmod -w $CURIMG &&
  mkdir -p ../$OUTDIR &&
  mv $CURIMG ../$OUTDIR &&
  FINISHED_SUCCESSFULLY=1
  printf "Completed script successfully\n"
}

# Usage: ask_yn default prompt [printf_args...]
# Read a Yes / No user response. If $ASK_YN_USE_DEFAULT is set, assume the 
# default. Return of 0 indicates a yes, and non-zero is no.
ask_yn() {
  OPT="y/n"
  case "$1" in
    y*|Y*) OPT="Y/n"; RET=0;;
    n*|N*) OPT="y/N"; RET=1;;
    *) die "Programmer error: invalid argument to ask_yn"
  esac
  shift
  if [ "$ASK_YN_USE_DEFAULT" ]; then
    return $RET
  else
    PROMPT=$1
    shift
    printf "$PROMPT [$OPT]: " "$@" && read YN
    case "$YN" in
      y*|Y*) return 0;;
      n*|N*) return 1;;
      "") return $RET
    esac
  fi
}

# Usage: read_val var default prompt [printf_args...]
read_val() {
  RV_VAR=$1
  RV_DEFAULT=$2
  RV_PROMPT=$3
  shift 3
  printf "$RV_PROMPT [$RV_DEFAULT]: " "$@" && read RV_VAL
  [ -z "$RV_VAL" ] && RV_VAL=$RV_DEFAULT
  eval "$RV_VAR=\$RV_VAL"
}

die() {
  FMTSTR=$1
  shift
  printf "Died: $FMTSTR\n" "$@" >&2
  exit 1
}

dotask() {
  "$@" || die "Failed while performing task: %s" "$*"
}

FINISHED_SUCCESSFULLY=0
CLEANED_UP=0
WAS_TRAPPED=0

# Sigh http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=390433
trap 'WAS_TRAPPED=1; universal_cleanup' EXIT
trap 'WAS_TRAPPED=1; universal_cleanup; trap - INT; kill -INT $$' INT

universal_cleanup() {
  set +e
  if [ $CLEANED_UP -ne 1 ]; then
    printf "Initiating cleanup\n"
    trap - INT
    trap - EXIT
    [ -p fifo.in ] && shutdown_qemu
    [ -b "$BOOT_DEV" ] && sudo umount $BOOT_DEV
    [ -b "$BOOT_DEV" ] && sudo umount $ROOT_DEV
    [ -b "$NBD_DEV" ] && detach_image_from_nbd $NBD_DEV
  fi
  if [ $WAS_TRAPPED -eq 1 ] && [ $FINISHED_SUCCESSFULLY -eq 0 ]; then
    printf "Did not complete script successfully\n"
  fi
  set -e
}
